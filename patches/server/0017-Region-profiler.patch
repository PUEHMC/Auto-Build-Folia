From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 3 Oct 2023 06:03:34 -0700
Subject: [PATCH] Region profiler

Profiling for a region starts with the /profiler command.
The usage for /profiler:
/profiler <world> <block x> <block z> <time in s> [radius, default 100 blocks]

Any region within the radius of the specified block coordinates
will be profiled. The profiling will stop after the specified
time has passed.

Once the profiler finishes, it will place a report in
the directory ./profiler/<id>.

Since regions can split into smaller regions, or merge into
other regions, the profiler will track this information. If
a profiled region splits, then all of the regions it splits
into are attached to the same profiler instance. If a profiled
region merges into another region, then the merged region is
profiled. This information is tracked and logged into the
"journal.txt" file contained in the report directory. The
journal tracks the region ids for the merge/split operations.

Region profiling is placed into the "region-X.txt" file where
X is the region id inside the profile directory. The header
of the file describes some stats about the region, namely
total profiling duration, ticks, utilisation, TPS, and MSPT.

Then, the timing tree is follows. The format is as specified:

There are two types of data recorded: Timers and Counters.

Timers are specified as follows:
<indent><name> X% total, Y% parent, self A% total, self B% children, avg D sum E, Fms raw sum
The above specifies the format for a named timer.

The <indent> specifies the number of parent timers.

"X" represents the percentage of time the timer took relative
to the entire profiling instance.

"Y" represents the percentage of time the timer took relative
to its _parents_ timer. For example:
```
Full Tick 100.000% total, 100.000% parent, self 0.889% total, self 0.889% children, avg 200.000 sum 200, 401.300ms raw sum
|+++Tick World: minecraft:overworld 81.409% total, 81.409% parent, self 1.873% total, self 2.301% children, avg 1.000 sum 200, 326.694ms raw sum
|---|---Entity Tick 56.784% total, 69.751% parent, self 6.049% total, self 10.652% children, avg 1.000 sum 200, 227.874ms raw sum
```
"Entity Tick" measured 69.751% of the time for the "Tick World: minecraft:overworld" timer.

"A" represents the self time relative to the entire profiling instance.
The self time is the amount of time for a timer that is _not_ measured
by a child timer.

"B" represents the self time relative to its _parents_ timer.

"D" represents the average number of times the timer is invoked relative to
its parent.
For example:
```
|---|---|---Entity Tick: bat 2.642% total, 7.343% parent, self 2.642% total, self 100.000% children, avg 14.975 sum 2,995, 23.127ms raw sum
```
In this case, an average of 14.975 bats were ticked for every
time the "Entity Tick" timer was invoked.

"E" represents the total number of times the timer is invoked.

"F" represents the total raw time accumulated by the timer.

Counters are specified as follows:
<indent>#<name> avg X sum Y

The X is the average number of times the counter is invoked
relative to the parent, exactly similar to the D field of Timers,
where Y is the total number of times the counter is invoked.

diff --git a/src/main/java/ca/spottedleaf/leafprofiler/LProfileGraph.java b/src/main/java/ca/spottedleaf/leafprofiler/LProfileGraph.java
new file mode 100644
index 0000000000000000000000000000000000000000..19c13bd372711bce978a463f85130f1e10202da9
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/leafprofiler/LProfileGraph.java
@@ -0,0 +1,106 @@
+package ca.spottedleaf.leafprofiler;
+
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+
+public final class LProfileGraph {
+
+    public static final int ROOT_NODE = 0;
+    // Array idx is the graph node id, where the int->int mapping is a mapping of profile timer id to graph node id
+    private Int2IntOpenHashMap[] nodes;
+    private int nodeCount;
+
+    public LProfileGraph() {
+        final Int2IntOpenHashMap[] nodes = new Int2IntOpenHashMap[16];
+        nodes[ROOT_NODE] = new Int2IntOpenHashMap();
+
+        this.nodes = nodes;
+        this.nodeCount = 1;
+    }
+
+    public static record GraphNode(GraphNode parent, int nodeId, int timerId) {}
+
+    public List<GraphNode> getDFS() {
+        final List<GraphNode> ret = new ArrayList<>();
+        final ArrayDeque<GraphNode> queue = new ArrayDeque<>();
+
+        queue.addFirst(new GraphNode(null, ROOT_NODE, -1));
+        final Int2IntOpenHashMap[] nodes = this.nodes;
+
+        GraphNode graphNode;
+        while ((graphNode = queue.pollFirst()) != null) {
+            ret.add(graphNode);
+
+            final int parent = graphNode.nodeId;
+
+            final Int2IntOpenHashMap children = nodes[parent];
+
+            for (final Iterator<Int2IntMap.Entry> iterator = children.int2IntEntrySet().fastIterator(); iterator.hasNext();) {
+                final Int2IntMap.Entry entry = iterator.next();
+                queue.addFirst(new GraphNode(graphNode, entry.getIntValue(), entry.getIntKey()));
+            }
+        }
+
+        return ret;
+    }
+
+    private int createNode(final int parent, final int timerId) {
+        Int2IntOpenHashMap[] nodes = this.nodes;
+
+        final Int2IntOpenHashMap node = nodes[parent];
+
+        final int newNode = this.nodeCount;
+        final int prev = node.putIfAbsent(timerId, newNode);
+
+        if (prev != 0) {
+            // already exists
+            return prev;
+        }
+
+        // insert new node
+        ++this.nodeCount;
+
+        if (newNode >= nodes.length) {
+            this.nodes = (nodes = Arrays.copyOf(nodes, nodes.length * 2));
+        }
+
+        nodes[newNode] = new Int2IntOpenHashMap();
+
+        return newNode;
+    }
+
+    public int getNode(final int parent, final int timerId) {
+        // note: requires parent node to exist
+        final Int2IntOpenHashMap[] nodes = this.nodes;
+
+        if (parent >= nodes.length) {
+            return -1;
+        }
+
+        final int mapping = nodes[parent].get(timerId);
+
+        if (mapping != 0) {
+            return mapping;
+        }
+
+        return -1;
+    }
+
+    public int getOrCreateNode(final int parent, final int timerId) {
+        // note: requires parent node to exist
+        final Int2IntOpenHashMap[] nodes = this.nodes;
+
+        final int mapping = nodes[parent].get(timerId);
+
+        if (mapping != 0) {
+            return mapping;
+        }
+
+        return this.createNode(parent, timerId);
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/leafprofiler/LProfilerRegistry.java b/src/main/java/ca/spottedleaf/leafprofiler/LProfilerRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d4f1bdb12d0f1371b62a484b535afd7dcbe1cd7
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/leafprofiler/LProfilerRegistry.java
@@ -0,0 +1,118 @@
+package ca.spottedleaf.leafprofiler;
+
+import java.util.Arrays;
+import java.util.concurrent.ConcurrentHashMap;
+
+public final class LProfilerRegistry {
+
+    // volatile required to ensure correct publishing when resizing
+    private volatile ProfilerEntry[] typesById = new ProfilerEntry[16];
+    private int totalEntries;
+    private final ConcurrentHashMap<String, ProfilerEntry> nameToEntry = new ConcurrentHashMap<>();
+
+    public LProfilerRegistry() {}
+
+    public ProfilerEntry getById(final int id) {
+        final ProfilerEntry[] entries = this.typesById;
+
+        return id < 0 || id >= entries.length ? null : entries[id];
+    }
+
+    public ProfilerEntry getByName(final String name) {
+        return this.nameToEntry.get(name);
+    }
+
+    public int getOrCreateType(final ProfileType type, final String name) {
+        ProfilerEntry entry = this.nameToEntry.get(name);
+        if (entry != null) {
+            return entry.id;
+        }
+        synchronized (this) {
+            entry = this.nameToEntry.get(name);
+            if (entry != null) {
+                return entry.id;
+            }
+            return this.createType(type, name);
+        }
+    }
+
+    public int getOrCreateTimer(final String name) {
+        return this.getOrCreateType(ProfileType.TIMER, name);
+    }
+
+    public int getOrCreateCounter(final String name) {
+        return this.getOrCreateType(ProfileType.COUNTER, name);
+    }
+
+    public int createType(final ProfileType type, final String name) {
+        synchronized (this) {
+            final int id = this.totalEntries;
+
+            final ProfilerEntry ret = new ProfilerEntry(type, name, id);
+
+            final ProfilerEntry prev = this.nameToEntry.putIfAbsent(name, ret);
+
+            if (prev != null) {
+                throw new IllegalStateException("Entry already exists: " + prev);
+            }
+
+            ++this.totalEntries;
+
+            ProfilerEntry[] entries = this.typesById;
+
+            if (id >= entries.length) {
+                this.typesById = entries = Arrays.copyOf(entries, entries.length * 2);
+            }
+
+            // should be opaque, but I don't think that matters here.
+            entries[id] = ret;
+
+            return id;
+        }
+    }
+
+    public static enum ProfileType {
+        COUNTER, TIMER;
+    }
+
+    public static record ProfilerEntry(ProfileType type, String name, int id) {}
+
+    public static final LProfilerRegistry GLOBAL_REGISTRY = new LProfilerRegistry();
+    public static final int TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Full Tick");
+    public static final int IN_BETWEEN_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "In Between Tick");
+    public static final int INTERNAL_TICK_TASKS = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Internal Tick Tasks");
+    public static final int PLUGIN_TICK_TASKS = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Plugin Tick Tasks");
+    public static final int ENTITY_SCHEDULER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Entity Scheduler Tick");
+    public static final int ENTITY_SCHEDULERS_TICKED = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Entity Schedulers Ticked");
+    public static final int CONNECTION_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Connection Tick");
+    public static final int AUTOSAVE = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Autosave");
+    public static final int PLAYER_SAVE = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Player Save");
+    public static final int CHUNK_SAVE = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Chunk Save");
+    public static final int BLOCK_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Block Tick");
+    public static final int FLUID_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Fluid Tick");
+    public static final int BLOCK_OR_FLUID_TICK_COUNT = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Block/Fluid Tick Count");
+    public static final int RAIDS_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Raids Tick");
+    public static final int CHUNK_PROVIDER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Chunk Source Tick");
+    public static final int CHUNK_HOLDER_MANAGER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Chunk Holder Manager Tick");
+    public static final int TICKET_LEVEL_UPDATE_PROCESSING = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Ticket Level Update Processing");
+    public static final int PLAYER_CHUNK_LOADER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Player Chunk Loader Tick");
+    public static final int CHUNK_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Chunk Ticks");
+    public static final int CHUNK_TICK_COLLECT_CHUNKS = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Collect Ticking Chunks");
+    public static final int MOB_SPAWN_ENTITY_COUNT = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Mob Spawn Entity Count");
+    public static final int SPAWN_AND_RANDOM_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Spawn Entities And Random Tick");
+    public static final int SPAWN_CHUNK_COUNT = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Entity Spawn Chunk Count");
+    public static final int RANDOM_CHUNK_TICK_COUNT = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Random Chunk Tick Count");
+    public static final int MISC_MOB_SPAWN_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Misc Mob Spawn Tick");
+    public static final int BROADCAST_BLOCK_CHANGES = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Broadcast Block Changes");
+    public static final int ENTITY_TRACKER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Entity Tracker Tick");
+    public static final int TRACKED_UNLOADED_ENTITY_COUNTS = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Total Untracked Unloaded Entities");
+    public static final int TRACKED_ENTITY_COUNTS = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Total Tracked Entities");
+    public static final int POI_MANAGER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "POI Manager Tick");
+    public static final int PROCESS_UNLOADS = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Process Unloads");
+    public static final int BLOCK_EVENT_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Block Event Tick");
+    public static final int ENTITY_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Entity Tick");
+    public static final int DRAGON_FIGHT_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Dragon Fight Tick");
+    public static final int TILE_ENTITY = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Tile Entities");
+    public static final int TILE_ENTITY_PENDING = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Tile Entity Handle Pending");
+    public static final int TILE_ENTITY_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Tile Entity Tick");
+}
diff --git a/src/main/java/ca/spottedleaf/leafprofiler/LeafProfiler.java b/src/main/java/ca/spottedleaf/leafprofiler/LeafProfiler.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c6e759fccce3b669490c09933c01705107d24ac
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/leafprofiler/LeafProfiler.java
@@ -0,0 +1,326 @@
+package ca.spottedleaf.leafprofiler;
+
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.ints.IntArrayFIFOQueue;
+import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
+import org.slf4j.Logger;
+import java.text.DecimalFormat;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public final class LeafProfiler {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private static final ThreadLocal<DecimalFormat> THREE_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.000");
+    });
+    private static final ThreadLocal<DecimalFormat> NO_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0");
+    });
+
+    public final LProfilerRegistry registry;
+    private final LProfileGraph graph;
+
+    private long[] timers = new long[16];
+    private long[] counters = new long[16];
+    private final IntArrayFIFOQueue callStack = new IntArrayFIFOQueue();
+    private int topOfStack = LProfileGraph.ROOT_NODE;
+    private final LongArrayFIFOQueue timerStack = new LongArrayFIFOQueue();
+    private long lastTimerStart = 0L;
+
+    public LeafProfiler(final LProfilerRegistry registry, final LProfileGraph graph) {
+        this.registry = registry;
+        this.graph = graph;
+    }
+
+    private long[] resizeTimers(final long[] old, final int least) {
+        return this.timers = Arrays.copyOf(old, Math.max(old.length * 2, least * 2));
+    }
+
+    private void incrementTimersDirect(final int nodeId, final long count) {
+        final long[] timers = this.timers;
+        if (nodeId >= timers.length) {
+            this.resizeTimers(timers, nodeId)[nodeId] += count;
+        } else {
+            timers[nodeId] += count;
+        }
+    }
+
+    private long[] resizeCounters(final long[] old, final int least) {
+        return this.counters = Arrays.copyOf(old, Math.max(old.length * 2, least * 2));
+    }
+
+    private void incrementCountersDirect(final int nodeId, final long count) {
+        final long[] counters = this.counters;
+        if (nodeId >= counters.length) {
+            this.resizeCounters(counters, nodeId)[nodeId] += count;
+        } else {
+            counters[nodeId] += count;
+        }
+    }
+
+    public void incrementCounter(final int timerId, final long count) {
+        final int node = this.graph.getOrCreateNode(this.topOfStack, timerId);
+        this.incrementCountersDirect(node, count);
+    }
+
+    public void incrementTimer(final int timerId, final long count) {
+        final int node = this.graph.getOrCreateNode(this.topOfStack, timerId);
+        this.incrementTimersDirect(node, count);
+    }
+
+    public void startTimer(final int timerId, final long startTime) {
+        final long lastTimerStart = this.lastTimerStart;
+        final LProfileGraph graph = this.graph;
+        final int parentNode = this.topOfStack;
+        final IntArrayFIFOQueue callStack = this.callStack;
+        final LongArrayFIFOQueue timerStack = this.timerStack;
+
+        this.lastTimerStart = startTime;
+        this.topOfStack = graph.getOrCreateNode(parentNode, timerId);
+
+        callStack.enqueue(parentNode);
+        timerStack.enqueue(lastTimerStart);
+    }
+
+    public void stopTimer(final int timerId, final long endTime) {
+        final long lastStart = this.lastTimerStart;
+        final int currentNode = this.topOfStack;
+        final IntArrayFIFOQueue callStack = this.callStack;
+        final LongArrayFIFOQueue timerStack = this.timerStack;
+        this.lastTimerStart = timerStack.dequeueLastLong();
+        this.topOfStack = callStack.dequeueLastInt();
+
+        if (currentNode != this.graph.getNode(this.topOfStack, timerId)) {
+            final LProfilerRegistry.ProfilerEntry timer = this.registry.getById(timerId);
+            throw new IllegalStateException("Timer " + (timer == null ? "null" : timer.name()) + " did not stop");
+        }
+
+        this.incrementTimersDirect(currentNode, endTime - lastStart);
+        this.incrementCountersDirect(currentNode, 1L);
+    }
+
+    private static final char[][] INDENT_PATTERNS = new char[][] {
+        "|---".toCharArray(),
+        "|+++".toCharArray(),
+    };
+
+    public List<String> dumpToString() {
+        final List<LProfileGraph.GraphNode> graphDFS = this.graph.getDFS();
+        final Reference2ReferenceOpenHashMap<LProfileGraph.GraphNode, ProfileNode> nodeMap = new Reference2ReferenceOpenHashMap<>();
+
+        final ArrayDeque<ProfileNode> orderedNodes = new ArrayDeque<>();
+
+        for (int i = 0, len = graphDFS.size(); i < len; ++i) {
+            final LProfileGraph.GraphNode graphNode = graphDFS.get(i);
+            final ProfileNode parent = nodeMap.get(graphNode.parent());
+            final int nodeId = graphNode.nodeId();
+
+            final long totalTime = nodeId >= this.timers.length ? 0L : this.timers[nodeId];
+            final long totalCount = nodeId >= this.counters.length ? 0L : this.counters[nodeId];
+            final LProfilerRegistry.ProfilerEntry profiler = this.registry.getById(graphNode.timerId());
+
+            final ProfileNode profileNode = new ProfileNode(parent, nodeId, profiler, totalTime, totalCount);
+
+            if (parent != null) {
+                parent.childrenTimingCount += totalTime;
+                parent.children.add(profileNode);
+            } else if (i != 0) { // i == 0 is root
+                throw new IllegalStateException("Node " + nodeId + " must have parent");
+            } else {
+                // set up
+                orderedNodes.add(profileNode);
+            }
+
+            nodeMap.put(graphNode, profileNode);
+        }
+
+        final List<String> ret = new ArrayList<>();
+
+        long totalTime = 0L;
+
+        // totalTime = sum of times for root node's children
+        for (final ProfileNode node : orderedNodes.peekFirst().children) {
+            totalTime += node.totalTime;
+        }
+
+        ProfileNode profileNode;
+        final StringBuilder builder = new StringBuilder();
+        while ((profileNode = orderedNodes.pollFirst()) != null) {
+            if (profileNode.nodeId != LProfileGraph.ROOT_NODE && profileNode.totalCount == 0L) {
+                // skip nodes not recorded
+                continue;
+            }
+
+            final int depth = profileNode.depth;
+            profileNode.children.sort((final ProfileNode p1, final ProfileNode p2) -> {
+                final int typeCompare = p1.profiler.type().compareTo(p2.profiler.type());
+                if (typeCompare != 0) {
+                    // first count, then profiler
+                    return typeCompare;
+                }
+
+                if (p1.profiler.type() == LProfilerRegistry.ProfileType.COUNTER) {
+                    // highest count first
+                    return Long.compare(p2.totalCount, p1.totalCount);
+                } else {
+                    // highest time first
+                    return Long.compare(p2.totalTime, p1.totalTime);
+                }
+            });
+
+            for (int i = profileNode.children.size() - 1; i >= 0; --i) {
+                final ProfileNode child = profileNode.children.get(i);
+                child.depth = depth + 1;
+                orderedNodes.addFirst(child);
+            }
+
+            if (profileNode.nodeId == LProfileGraph.ROOT_NODE) {
+                // don't display root
+                continue;
+            }
+
+            final boolean noParent = profileNode.parent == null || profileNode.parent.nodeId == LProfileGraph.ROOT_NODE;
+
+            final long parentTime = noParent ? totalTime : profileNode.parent.totalTime;
+            final LProfilerRegistry.ProfilerEntry profilerEntry = profileNode.profiler;
+
+            // format:
+            // For profiler type:
+            // <indent><name> X% total, Y% parent, self A% total, self B% children, avg X sum Y, Dms raw sum
+            // For counter type:
+            // <indent>#<name> avg X sum Y
+            builder.setLength(0);
+            // prepare indent
+            final char[] indent = INDENT_PATTERNS[ret.size() % INDENT_PATTERNS.length];
+            for (int i = 0; i < depth; ++i) {
+                builder.append(indent);
+            }
+
+            switch (profilerEntry.type()) {
+                case TIMER: {
+                    ret.add(
+                        builder
+                            .append(profilerEntry.name())
+                            .append(' ')
+                            .append(THREE_DECIMAL_PLACES.get().format(((double)profileNode.totalTime / (double)totalTime) * 100.0))
+                            .append("% total, ")
+                            .append(THREE_DECIMAL_PLACES.get().format(((double)profileNode.totalTime / (double)parentTime) * 100.0))
+                            .append("% parent, self ")
+                            .append(THREE_DECIMAL_PLACES.get().format(((double)(profileNode.totalTime - profileNode.childrenTimingCount) / (double)totalTime) * 100.0))
+                            .append("% total, self ")
+                            .append(THREE_DECIMAL_PLACES.get().format(((double)(profileNode.totalTime - profileNode.childrenTimingCount) / (double)profileNode.totalTime) * 100.0))
+                            .append("% children, avg ")
+                            .append(THREE_DECIMAL_PLACES.get().format((double)profileNode.totalCount / (double)(noParent ? 1L : profileNode.parent.totalCount)))
+                            .append(" sum ")
+                            .append(NO_DECIMAL_PLACES.get().format(profileNode.totalCount))
+                            .append(", ")
+                            .append(THREE_DECIMAL_PLACES.get().format((double)profileNode.totalTime / 1.0E6))
+                            .append("ms raw sum")
+                            .toString()
+                    );
+                    break;
+                }
+                case COUNTER: {
+                    ret.add(
+                        builder
+                            .append('#')
+                            .append(profilerEntry.name())
+                            .append(" avg ")
+                            .append(THREE_DECIMAL_PLACES.get().format((double)profileNode.totalCount / (double)(noParent ? 1L : profileNode.parent.totalCount)))
+                            .append(" sum ")
+                            .append(NO_DECIMAL_PLACES.get().format(profileNode.totalCount))
+                            .toString()
+                    );
+                    break;
+                }
+                default: {
+                    throw new IllegalStateException("Unknown type " + profilerEntry.type());
+                }
+            }
+        }
+
+        return ret;
+    }
+
+    private static final class ProfileNode {
+
+        public final ProfileNode parent;
+        public final int nodeId;
+        public final LProfilerRegistry.ProfilerEntry profiler;
+        public final long totalTime;
+        public final long totalCount;
+        public final List<ProfileNode> children = new ArrayList<>();
+        public long childrenTimingCount;
+        public int depth = -1;
+
+        private ProfileNode(final ProfileNode parent, final int nodeId, final LProfilerRegistry.ProfilerEntry profiler,
+                            final long totalTime, final long totalCount) {
+            this.parent = parent;
+            this.nodeId = nodeId;
+            this.profiler = profiler;
+            this.totalTime = totalTime;
+            this.totalCount = totalCount;
+        }
+    }
+
+    /*
+    public static void main(final String[] args) throws Throwable {
+        final Thread timerHack = new Thread("Timer hack thread") {
+            @Override
+            public void run() {
+                for (;;) {
+                    try {
+                        Thread.sleep(Long.MAX_VALUE);
+                    } catch (final InterruptedException ex) {
+                        continue;
+                    }
+                }
+            }
+        };
+        timerHack.setDaemon(true);
+        timerHack.start();
+
+        final LProfilerRegistry registry = new LProfilerRegistry();
+
+        final int tickId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "tick");
+        final int entityTickId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "entity tick");
+        final int getEntitiesId = registry.createType(LProfilerRegistry.ProfileType.COUNTER, "getEntities call");
+        final int tileEntityId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "tile entity tick");
+        final int creeperEntityId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "creeper entity tick");
+        final int furnaceId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "furnace tile entity tick");
+
+        final LeafProfiler profiler = new LeafProfiler(registry, new LProfileGraph());
+
+        profiler.startTimer(tickId, System.nanoTime());
+        Thread.sleep(10L);
+
+        profiler.startTimer(entityTickId, System.nanoTime());
+        Thread.sleep(1L);
+
+        profiler.startTimer(creeperEntityId, System.nanoTime());
+        Thread.sleep(15L);
+        profiler.incrementCounter(getEntitiesId, 50L);
+        profiler.stopTimer(creeperEntityId, System.nanoTime());
+
+        profiler.stopTimer(entityTickId, System.nanoTime());
+
+        profiler.startTimer(tileEntityId, System.nanoTime());
+        Thread.sleep(1L);
+
+        profiler.startTimer(furnaceId, System.nanoTime());
+        Thread.sleep(20L);
+        profiler.stopTimer(furnaceId, System.nanoTime());
+
+        profiler.stopTimer(tileEntityId, System.nanoTime());
+
+        profiler.stopTimer(tickId, System.nanoTime());
+
+        System.out.println("Done.");
+    }
+     */
+}
diff --git a/src/main/java/ca/spottedleaf/leafprofiler/RegionizedProfiler.java b/src/main/java/ca/spottedleaf/leafprofiler/RegionizedProfiler.java
new file mode 100644
index 0000000000000000000000000000000000000000..95c0e6416afafbb633f0a30ae22df166055a0cbc
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/leafprofiler/RegionizedProfiler.java
@@ -0,0 +1,276 @@
+package ca.spottedleaf.leafprofiler;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
+import io.papermc.paper.threadedregions.TickData;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import io.papermc.paper.threadedregions.TickRegions;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+public final class RegionizedProfiler {
+
+    private static final AtomicLong ID_GENERATOR = new AtomicLong();
+
+    public final long id;
+    private final AtomicInteger profilingRegions = new AtomicInteger();
+    private final MultiThreadedQueue<RecordedOperation> operations = new MultiThreadedQueue<>();
+    private final MultiThreadedQueue<RegionTimings> timings = new MultiThreadedQueue<>();
+    private final long absoluteStart = System.nanoTime();
+    private final long absoluteEnd;
+    private final Consumer<ProfileResults> onFinish;
+
+    public RegionizedProfiler(final long id, final long recordFor, final Consumer<ProfileResults> onFinish) {
+        this.id = id;
+        this.onFinish = onFinish;
+        this.absoluteEnd = this.absoluteStart + recordFor;
+    }
+
+    public void createProfiler(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> into) {
+        final Handle newProfiler = new Handle(
+            new LeafProfiler(LProfilerRegistry.GLOBAL_REGISTRY, new LProfileGraph()),
+            false, this, into
+        );
+        newProfiler.startProfiler();
+
+        into.getData().profiler = newProfiler;
+    }
+
+    public void preMerge(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> from,
+                         final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> into) {
+        final Handle fromProfiler = from.getData().profiler;
+        final Handle intoProfiler = into.getData().profiler;
+        this.operations.add(new RecordedOperation(OperationType.MERGE, from.id, LongArrayList.of(into.id), System.nanoTime()));
+
+        if (intoProfiler != null) {
+            // target is already profiling
+            fromProfiler.stopProfiler();
+            return;
+        }
+
+        this.createProfiler(into);
+
+        // the old profiler must be terminated only after creating the new one, so that there is always at least one
+        // profiler running, otherwise the profiler will complete
+        fromProfiler.stopProfiler();
+    }
+
+    public void preSplit(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> from,
+                         final List<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>> into) {
+        final Handle fromProfiler = from.getData().profiler;
+
+        final LongArrayList regions = new LongArrayList(into.size());
+        for (int i = 0, len = into.size(); i < len; ++i) {
+            regions.add(into.get(i).id);
+        }
+
+        this.operations.add(new RecordedOperation(OperationType.SPLIT, from.id, regions, System.nanoTime()));
+
+        for (int i = 0, len = into.size(); i < len; ++i) {
+            // create new profiler
+            this.createProfiler(into.get(i));
+        }
+
+        // the old profiler must be terminated only after creating the new ones, so that there is always at least one
+        // profiler running, otherwise the profiler will complete
+        fromProfiler.stopProfiler();
+    }
+
+    public static record RecordedOperation(
+        OperationType type,
+
+        /*
+         * The target for start,end or the `from` region for merge/split
+         */
+        long regionOfInterest,
+
+        /*
+         * The merge target or the split targets
+         */
+        LongArrayList targetRegions,
+
+        /*
+         * The timestamp for this operation
+         */
+        long time
+    ) {}
+
+    public static enum OperationType {
+        START,
+        MERGE,
+        SPLIT,
+        END;
+    }
+
+    public static final class Handle {
+
+        public final LeafProfiler profiler;
+        private boolean noOp;
+        public final RegionizedProfiler profilerGroup;
+        private final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region;
+        private final TickData tickData = new TickData(Long.MAX_VALUE);
+        private long startTime;
+
+        public static final Handle NO_OP_HANDLE = new Handle(
+            null, true, null, null
+        );
+
+        private Handle(final LeafProfiler profiler, final boolean noOp,
+                       final RegionizedProfiler profilerGroup,
+                       final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region) {
+            this.profiler = profiler;
+            this.noOp = noOp;
+            this.profilerGroup = profilerGroup;
+            this.region = region;
+        }
+
+        public void startTick() {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.startTimer(LProfilerRegistry.TICK, System.nanoTime());
+        }
+
+        public void stopTick() {
+            if (this.noOp) {
+                return;
+            }
+
+
+
+            this.profiler.stopTimer(LProfilerRegistry.TICK, System.nanoTime());
+        }
+
+        public void startInBetweenTick() {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.startTimer(LProfilerRegistry.IN_BETWEEN_TICK, System.nanoTime());
+        }
+
+        public void stopInBetweenTick() {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.stopTimer(LProfilerRegistry.IN_BETWEEN_TICK, System.nanoTime());
+        }
+
+        public void startTimer(final int timerId) {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.startTimer(timerId, System.nanoTime());
+        }
+
+        public void stopTimer(final int timerId) {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.stopTimer(timerId, System.nanoTime());
+        }
+
+        public void addCounter(final int counterId, final long count) {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.incrementCounter(counterId, count);
+        }
+
+        public int getOrCreateTimerAndStart(final Supplier<String> name) {
+            if (this.noOp) {
+                return -1;
+            }
+
+            final int timer = this.profiler.registry.getOrCreateType(LProfilerRegistry.ProfileType.TIMER, name.get());
+
+            this.profiler.startTimer(timer, System.nanoTime());
+
+            return timer;
+        }
+
+        public void addTickTime(final TickRegionScheduler.TickTime tickTime) {
+            if (this.noOp) {
+                return;
+            }
+            this.tickData.addDataFrom(tickTime);
+        }
+
+        public void startProfiler() {
+            if (this.noOp) {
+                return;
+            }
+            this.profilerGroup.profilingRegions.getAndIncrement();
+            this.startTime = System.nanoTime();
+            this.profilerGroup.operations.add(
+                new RecordedOperation(OperationType.START, this.region.id, new LongArrayList(), this.startTime)
+            );
+        }
+
+        public void stopProfiler() {
+            if (this.noOp) {
+                return;
+            }
+
+            final long endTime = System.nanoTime();
+
+            this.noOp = true;
+            this.region.getData().profiler = null;
+            this.profilerGroup.operations.add(
+                new RecordedOperation(OperationType.END, this.region.id, new LongArrayList(), endTime)
+            );
+            this.profilerGroup.timings.add(
+                new RegionTimings(
+                    this.startTime, endTime, this.region.id, this.profiler, this.tickData
+                )
+            );
+
+            if (this.profilerGroup.profilingRegions.decrementAndGet() == 0) {
+                this.profilerGroup.onFinish.accept(
+                    new ProfileResults(
+                        this.profilerGroup.id,
+                        this.profilerGroup.absoluteStart,
+                        endTime,
+                        new ArrayList<>(this.profilerGroup.timings),
+                        new ArrayList<>(this.profilerGroup.operations)
+                    )
+                );
+            }
+        }
+
+        public void checkStop() {
+            if (this.noOp) {
+                return;
+            }
+            if ((System.nanoTime() - this.profilerGroup.absoluteEnd) >= 0L) {
+                this.stopProfiler();
+            }
+        }
+    }
+
+    public static record ProfileResults(
+        long profileId,
+        long startTime,
+        long endTime,
+        List<RegionTimings> timings,
+        List<RecordedOperation> operations
+    ) {}
+
+    public static record RegionTimings(
+        long startTime,
+        long endTime,
+        long regionId,
+        LeafProfiler profiler,
+        TickData tickData
+    ) {}
+}
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 4b36209f016b025087da359ab49e44bd677cd937..707d4aa8a56f2fc33456f3441c4daf973a27ef2d 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -1442,7 +1442,9 @@ public final class ChunkHolderManager {
     }
 
     public boolean processTicketUpdates() {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TICKET_LEVEL_UPDATE_PROCESSING); try { // Folia - profiler
         return this.processTicketUpdates(true, null);
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TICKET_LEVEL_UPDATE_PROCESSING); } // Folia - profiler
     }
 
     private static final ThreadLocal<List<ChunkProgressionTask>> CURRENT_TICKET_UPDATE_SCHEDULING = new ThreadLocal<>();
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
index c467b2d2ef9e1e16b00fee20f6cfc757c30fb100..7a719d427a537c6fa1f60d8ebb9130e7eda9618a 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
@@ -1687,6 +1687,8 @@ public final class NewChunkHolder {
 
     public SaveStat save(final boolean shutdown) {
         TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot save data off-main");
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_SAVE); try { // Folia - profiler
 
         ChunkAccess chunk = this.getCurrentChunk();
         PoiChunk poi = this.getPoiChunk();
@@ -1733,6 +1735,7 @@ public final class NewChunkHolder {
         }
 
         return executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI ? new SaveStat(executedUnloadTask || canSaveChunk, canSaveEntities, canSavePOI): null;
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_SAVE); } // Folia - profiler
     }
 
     static final class AsyncChunkSerializeTask implements Runnable {
diff --git a/src/main/java/io/papermc/paper/command/PaperCommands.java b/src/main/java/io/papermc/paper/command/PaperCommands.java
index a587d83b78af4efc484f939529acf70834f60d7e..45f76aaaa7dedb77a83b4a2c87905bf9a099a93c 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommands.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommands.java
@@ -20,6 +20,7 @@ public final class PaperCommands {
         COMMANDS.put("callback", new CallbackCommand("callback"));
         COMMANDS.put("mspt", new MSPTCommand("mspt"));
         COMMANDS.put("tps", new io.papermc.paper.threadedregions.commands.CommandServerHealth()); // Folia - region threading
+        COMMANDS.put("profiler", new io.papermc.paper.threadedregions.commands.CommandProfiler()); // Folia - region threading - profiler
     }
 
     public static void registerCommands(final MinecraftServer server) {
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
index 54539fecd96a8a4c4a15e147876f7e0985f566cd..c43b263e6502ba48a876803385f8d05c5e84ba3e 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -67,8 +67,13 @@ public final class TickRegionScheduler {
         tickThreadRunner.currentTickingRegion = region;
         if (region != null) {
             tickThreadRunner.currentTickingWorldRegionizedData = region.regioniser.world.worldRegionData.get();
+            // Folia start - profiler
+            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = region.getData().profiler;
+            tickThreadRunner.profiler = profiler == null ? ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE : profiler;
+            // Folia end - profiler
         } else {
             tickThreadRunner.currentTickingWorldRegionizedData = null;
+            tickThreadRunner.profiler = ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE; // Folia - profiler
         }
     }
 
@@ -123,6 +128,17 @@ public final class TickRegionScheduler {
         return tickThreadRunner.currentTickingTask;
     }
 
+    // Folia start - profiler
+    public static ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle getProfiler() {
+        final Thread currThread = Thread.currentThread();
+        if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
+            return ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE;
+        }
+        return tickThreadRunner.profiler;
+    }
+    // Folia end - profiler
+
+
     /**
      * Schedules the given region
      * @throws IllegalStateException If the region is already scheduled or is ticking
@@ -204,6 +220,9 @@ public final class TickRegionScheduler {
         private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion;
         private RegionizedWorldData currentTickingWorldRegionizedData;
         private SchedulerThreadPool.SchedulableTick currentTickingTask;
+        // Folia start - profiler
+        private ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE;
+        // Folia end - profiler
 
         public TickThreadRunner(final Runnable run, final String name) {
             super(run, name);
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index df15b1139e71dfe10b8f24ec6d235b99f6d5006a..b1c07e582dbf0a203cf734fdbcd8387a422af3a6 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -81,6 +81,11 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
     @Override
     public void onRegionDestroy(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
         // nothing for now
+        // Folia start - profiler
+        if (region.getData().profiler != null) {
+            region.getData().profiler.stopProfiler();
+        }
+        // Folia end - profiler
     }
 
     @Override
@@ -103,13 +108,23 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
     @Override
     public void preMerge(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> from,
                          final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> into) {
-
+        // Folia start - profiler
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = from.getData().profiler;
+        if (profiler != null) {
+            profiler.profilerGroup.preMerge(from, into);
+        }
+        // Folia end - profiler
     }
 
     @Override
     public void preSplit(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> from,
                          final java.util.List<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>> into) {
-
+        // Folia start - profiler
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = from.getData().profiler;
+        if (profiler != null) {
+            profiler.profilerGroup.preSplit(from, into);
+        }
+        // Folia end - profiler
     }
 
     public static final class TickRegionSectionData implements ThreadedRegionizer.ThreadedRegionSectionData {}
@@ -167,6 +182,8 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         // async-safe read-only region data
         private final RegionStats regionStats;
 
+        public volatile ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler; // Folia - profiler
+
         private TickRegionData(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
             this.region = region;
             this.world = region.regioniser.world;
@@ -372,13 +389,29 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             return this.region.region.markNotTicking();
         }
 
+        // Folia start - profiler
+        @Override
+        protected void addTickTime(final TickRegionScheduler.TickTime time) {
+            super.addTickTime(time);
+
+            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
+            profiler.addTickTime(time);
+            profiler.checkStop();
+         }
+         // Folia end - profiler
+
         @Override
         protected void tickRegion(final int tickCount, final long startTime, final long scheduledEnd) {
+            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+            profiler.startTick(); try { // Folia - profiler
             MinecraftServer.getServer().tickServer(startTime, scheduledEnd, TimeUnit.MILLISECONDS.toMillis(10L), this.region);
+            } finally { profiler.stopTick(); } // Folia - profiler
         }
 
         @Override
         protected boolean runRegionTasks(final BooleanSupplier canContinue) {
+            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia start - profiler
+            profiler.startInBetweenTick(); try { // Folia - profiler
             final RegionizedTaskQueue.RegionTaskQueueData queue = this.region.taskQueueData;
 
             boolean processedChunkTask = false;
@@ -399,6 +432,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
                 this.region.world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates();
             }
             return true;
+            } finally { profiler.stopInBetweenTick(); } // Folia - profiler
         }
 
         @Override
diff --git a/src/main/java/io/papermc/paper/threadedregions/commands/CommandProfiler.java b/src/main/java/io/papermc/paper/threadedregions/commands/CommandProfiler.java
new file mode 100644
index 0000000000000000000000000000000000000000..e36fd244f71a92d11c6ee45944948be5c1be2932
--- /dev/null
+++ b/src/main/java/io/papermc/paper/threadedregions/commands/CommandProfiler.java
@@ -0,0 +1,245 @@
+package io.papermc.paper.threadedregions.commands;
+
+import ca.spottedleaf.leafprofiler.RegionizedProfiler;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
+import io.papermc.paper.threadedregions.TickData;
+import io.papermc.paper.threadedregions.TickRegions;
+import io.papermc.paper.util.MCUtil;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+import org.slf4j.Logger;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.StandardOpenOption;
+import java.text.DecimalFormat;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ThreadLocalRandom;
+
+public final class CommandProfiler extends Command {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private static final ThreadLocal<DecimalFormat> THREE_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.000");
+    });
+    private static final ThreadLocal<DecimalFormat> TWO_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.00");
+    });
+    private static final ThreadLocal<DecimalFormat> ONE_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.0");
+    });
+    private static final ThreadLocal<DecimalFormat> NO_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0");
+    });
+    private static final TextColor ORANGE = TextColor.color(255, 165, 0);
+
+    public CommandProfiler() {
+        super("profiler");
+        this.setUsage("/<command> <world> <block x> <block z> <time in s> [radius, default 100 blocks]");
+        this.setDescription("Reports information about server health.");
+        this.setPermission("bukkit.command.tps");
+    }
+
+    @Override
+    public boolean execute(final CommandSender sender, final String commandLabel, final String[] args) {
+        if (args.length < 4 || args.length > 5) {
+            sender.sendMessage(Component.text("Usage: /profiler <world> <block x> <block z> <time in s> [radius, default 100 blocks]", NamedTextColor.RED));
+            return true;
+        }
+
+        final World world = Bukkit.getWorld(args[0]);
+        if (world == null) {
+            sender.sendMessage(Component.text("No such world '" + args[0] + "'", NamedTextColor.RED));
+            return true;
+        }
+
+        final double blockX;
+        final double blockZ;
+        final double time; // seconds
+        try {
+            blockX = (args[1].equals("~") && sender instanceof Entity entity) ? entity.getLocation().getX() : Double.parseDouble(args[1]);
+        } catch (final NumberFormatException ex) {
+            sender.sendMessage(Component.text("Invalid input for block x: " + args[1], NamedTextColor.RED));
+            return true;
+        }
+        try {
+            blockZ = (args[2].equals("~") && sender instanceof Entity entity) ? entity.getLocation().getZ() : Double.parseDouble(args[2]);
+        } catch (final NumberFormatException ex) {
+            sender.sendMessage(Component.text("Invalid input for block z: " + args[2], NamedTextColor.RED));
+            return true;
+        }
+        try {
+            time = Double.parseDouble(args[3]);
+        } catch (final NumberFormatException ex) {
+            sender.sendMessage(Component.text("Invalid input for time: " + args[3], NamedTextColor.RED));
+            return true;
+        }
+
+        final double radius;
+        if (args.length > 4) {
+            try {
+                radius = Double.parseDouble(args[4]);
+            } catch (final NumberFormatException ex) {
+                sender.sendMessage(Component.text("Invalid input for radius: " + args[4], NamedTextColor.RED));
+                return true;
+            }
+        } else {
+            radius = 100.0;
+        }
+
+        final int fromChunkX = Mth.floor(blockX - radius) >> 4;
+        final int fromChunkZ = Mth.floor(blockZ - radius) >> 4;
+        final int toChunkX = Mth.floor(blockX + radius) >> 4;
+        final int toChunkZ = Mth.floor(blockZ + radius) >> 4;
+
+        final RegionizedProfiler profiler = new RegionizedProfiler(
+            ThreadLocalRandom.current().nextLong(), (long)Math.ceil(time * 1.0E9),
+            (final RegionizedProfiler.ProfileResults results) -> {
+                MCUtil.asyncExecutor.execute(() -> {
+                    writeResults(results);
+                    sender.sendMessage(
+                        Component.text()
+                            .append(Component.text("Finished profiler #", NamedTextColor.DARK_GRAY))
+                            .append(Component.text(Long.toString(results.profileId()), ORANGE))
+                            .append(Component.text(", result available in ", NamedTextColor.DARK_GRAY))
+                            .append(Component.text("./profiler/" + results.profileId(), ORANGE))
+                            .build()
+                    );
+                });
+            }
+        );
+
+        final int regionCount = ((CraftWorld)world).getHandle().regioniser.computeForRegions(
+            fromChunkX, fromChunkZ, toChunkX, toChunkZ,
+            (final Set<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>> set) -> {
+                for (final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region : set) {
+                    final TickRegions.TickRegionData data = region.getData();
+                    final ChunkPos center = region.getCenterChunk();
+
+                    if (data.profiler != null) {
+                        MCUtil.asyncExecutor.execute(() -> {
+                            sender.sendMessage(
+                                Component.text()
+                                    .append(Component.text("Region #", NamedTextColor.DARK_GRAY))
+                                    .append(Component.text(region.id, ORANGE))
+                                    .append(Component.text(" centered on ", NamedTextColor.DARK_GRAY))
+                                    .append(Component.text(Objects.toString(center), ORANGE))
+                                    .append(Component.text(" already is being profiled", NamedTextColor.DARK_GRAY))
+                                    .build()
+                            );
+                        });
+                        continue;
+                    }
+
+                    profiler.createProfiler(region);
+                    MCUtil.asyncExecutor.execute(() -> {
+                        sender.sendMessage(
+                            Component.text()
+                                .append(Component.text("Started profiler #", NamedTextColor.DARK_GRAY))
+                                .append(Component.text(Long.toString(profiler.id), ORANGE))
+                                .append(Component.text(" for region #", NamedTextColor.DARK_GRAY))
+                                .append(Component.text(Long.toString(region.id), ORANGE))
+                                .append(Component.text(" centered on chunk ", NamedTextColor.DARK_GRAY))
+                                .append(Component.text(Objects.toString(center), ORANGE))
+                                .build()
+                        );
+                    });
+                }
+            }
+        );
+
+        if (regionCount == 0) {
+            sender.sendMessage(
+                Component.text()
+                    .append(Component.text("No regions around specified location in radius to profile", NamedTextColor.RED))
+            );
+        }
+
+        return true;
+    }
+
+    private static void writeLines(final File file, final List<String> lines) {
+        try {
+            Files.write(
+                file.toPath(), lines, StandardCharsets.UTF_8,
+                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE
+            );
+        } catch (final IOException ex) {
+            LOGGER.warn("Failed to write to profiler file " + file.getAbsolutePath(), ex);
+        }
+    }
+
+    private static void writeResults(final RegionizedProfiler.ProfileResults results) {
+        final File directory = new File(new File(".", "profiler"), Long.toString(results.profileId()));
+
+        directory.mkdirs();
+
+        // write region data
+        for (final RegionizedProfiler.RegionTimings regionTimings : results.timings()) {
+            final File regionProfile = new File(directory, "region-" + regionTimings.regionId() + ".txt");
+            final TickData.TickReportData tickReport = regionTimings.tickData().generateTickReport(null, regionTimings.endTime());
+
+            final List<String> out = new ArrayList<>();
+            out.add("Total time: " + THREE_DECIMAL_PLACES.get().format(1.0E-9 * (regionTimings.endTime() - regionTimings.startTime())) + "s");
+            out.add("Total Ticks: " + NO_DECIMAL_PLACES.get().format(tickReport == null ? 0 : tickReport.collectedTicks()));
+            out.add("Utilisation: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 100.0 * tickReport.utilisation()) + "%");
+            out.add("");
+            out.add("Min TPS: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 20.0 : tickReport.tpsData().segmentAll().least()));
+            out.add("Median TPS: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 20.0 : tickReport.tpsData().segmentAll().median()));
+            out.add("Average TPS: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 20.0 : tickReport.tpsData().segmentAll().average()));
+            out.add("Max TPS: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 20.0 : tickReport.tpsData().segmentAll().greatest()));
+            out.add("");
+            out.add("Min MSPT: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 1.0E-6 * tickReport.timePerTickData().segmentAll().least()));
+            out.add("Median MSPT: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 1.0E-6 *tickReport.timePerTickData().segmentAll().median()));
+            out.add("Average MSPT: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 1.0E-6 *tickReport.timePerTickData().segmentAll().average()));
+            out.add("Max MSPT: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 1.0E-6 *tickReport.timePerTickData().segmentAll().greatest()));
+            out.add("");
+
+            out.addAll(regionTimings.profiler().dumpToString());
+            writeLines(regionProfile, out);
+        }
+
+        // write journal
+        final File journal = new File(directory, "journal.txt");
+        final List<String> journalLines = new ArrayList<>();
+
+        for (final RegionizedProfiler.RecordedOperation operation : results.operations()) {
+            final String indent = "    ";
+            journalLines.add("Recorded Operation:");
+            journalLines.add(indent + "Type: " + operation.type());
+            journalLines.add(indent + "Time: " + THREE_DECIMAL_PLACES.get().format(1.0E-9 * (operation.time() - results.startTime())) + "s");
+            journalLines.add(indent + "From Region: " + operation.regionOfInterest());
+            journalLines.add(indent + "Target Other Regions: " + operation.targetRegions().toString());
+        }
+
+        journalLines.add("Total time: " + THREE_DECIMAL_PLACES.get().format(1.0E-9 * (results.endTime() - results.startTime())) + "s");
+        writeLines(journal, journalLines);
+
+    }
+
+    @Override
+    public List<String> tabComplete(final CommandSender sender, final String alias, final String[] args) throws IllegalArgumentException {
+        if (args.length == 0) {
+            return CommandUtil.getSortedList(Bukkit.getWorlds(), World::getName);
+        }
+        if (args.length == 1) {
+            return CommandUtil.getSortedList(Bukkit.getWorlds(), World::getName, args[0]);
+        }
+        return new ArrayList<>();
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/PacketUtils.java b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
index fbc619a132c6ca6b1abab51ac230be29367e9c6e..97817400b70b2579f3a8750f7f33197a5db7ba94 100644
--- a/src/main/java/net/minecraft/network/protocol/PacketUtils.java
+++ b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
@@ -53,7 +53,10 @@ public class PacketUtils {
                 if (listener.shouldHandleMessage(packet)) {
                     co.aikar.timings.Timing timing = co.aikar.timings.MinecraftTimings.getPacketTiming(packet); // Paper - timings
                     try (co.aikar.timings.Timing ignored = timing.startTiming()) { // Paper - timings
+                        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+                        final int packetTimerId = profiler.getOrCreateTimerAndStart(() -> "Packet Handler: ".concat(io.papermc.paper.util.ObfHelper.INSTANCE.deobfClassName(packet.getClass().getName()))); try { // Folia - profiler
                         packet.handle(listener);
+                        } finally { profiler.stopTimer(packetTimerId); } // Folia - profiler
                     } catch (Exception exception) {
                         if (exception instanceof ReportedException) {
                             ReportedException reportedexception = (ReportedException) exception;
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index eda5f0d099f9f8621de8ad7808098abf6f5cb544..ac56b02498eb38883ae462be6ef3d15cb2a855aa 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1656,6 +1656,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Folia start - region threading
     public void tickServer(long startTime, long scheduledEnd, long targetBuffer,
                            io.papermc.paper.threadedregions.TickRegions.TickRegionData region) {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         if (region != null) {
             region.world.getCurrentWorldData().updateTickData();
             if (region.world.checkInitialised.get() != ServerLevel.WORLD_INIT_CHECKED) {
@@ -1691,10 +1692,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         // Folia start - region threading
         if (region != null) {
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.INTERNAL_TICK_TASKS); try { // Folia - profiler
             region.getTaskQueueData().drainTasks();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.INTERNAL_TICK_TASKS); } // Folia - profiler
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLUGIN_TICK_TASKS); try { // Folia - profiler
             ((io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler)Bukkit.getRegionScheduler()).tick();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLUGIN_TICK_TASKS); } // Folia - profiler
             // now run all the entity schedulers
             // TODO there has got to be a more efficient variant of this crap
+            long tickedEntitySchedulers = 0L; // Folia - profiler
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULER_TICK); try { // Folia - profiler
             for (Entity entity : region.world.getCurrentWorldData().getLocalEntitiesCopy()) {
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(entity) || entity.isRemoved()) {
                     continue;
@@ -1702,8 +1709,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
                 if (bukkit != null) {
                     bukkit.taskScheduler.executeTick();
+                    ++tickedEntitySchedulers; // Folia - profiler
                 }
             }
+            profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULERS_TICKED, tickedEntitySchedulers); // Folia - profiler
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULER_TICK); } // Folia - profiler
         }
         // Folia end - region threading
 
@@ -1723,6 +1733,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         this.profiler.push("save");
         final boolean fullSave = autosavePeriod > 0 && io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() % autosavePeriod == 0; // Folia - region threading
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.AUTOSAVE); try { // Folia - profiler
         try {
             this.isSaving = true;
             if (playerSaveInterval > 0) {
@@ -1736,6 +1747,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } finally {
             this.isSaving = false;
         }
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.AUTOSAVE); } // Folia - profiler
         this.profiler.pop();
         // Paper end - Incremental chunk and player saving
         // Paper start - move executeAll() into full server tick timing
@@ -1809,6 +1821,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public void tickChildren(BooleanSupplier shouldKeepTicking, io.papermc.paper.threadedregions.TickRegions.TickRegionData region) { // Folia - region threading
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - regionised ticking
         if (region == null) this.getPlayerList().getPlayers().forEach((entityplayer) -> { // Folia - region threading
             entityplayer.connection.suspendFlushing();
@@ -1877,7 +1890,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             try {
                 worldserver.timings.doTick.startTiming(); // Spigot
+                profiler.startTimer(worldserver.tickTimerId); try { // Folia - profiler
                 worldserver.tick(shouldKeepTicking, region); // Folia - region threading
+                } finally { profiler.stopTimer(worldserver.tickTimerId); } // Folia - profiler
                 worldserver.timings.doTick.stopTiming(); // Spigot
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
@@ -1895,7 +1910,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.profiler.popPush("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot // Paper
         if (region == null) this.getConnection().tick(); // Folia - region threading
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CONNECTION_TICK); try { // Folia - profiler
         if (region != null) regionizedWorldData.tickConnections(); // Folia - region threading
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CONNECTION_TICK); } // Folia - profiler
         MinecraftTimings.connectionTimer.stopTiming(); // Spigot // Paper
         this.profiler.popPush("players");
         MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 7f161864ee6a43de8d37c0e5c9cba9918f2fed89..31f2f6e841179a2fba2199afa7d6211eb68d3c07 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -392,13 +392,18 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     protected void tick(BooleanSupplier shouldKeepTicking) {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         ProfilerFiller gameprofilerfiller = this.level.getProfiler();
 
         gameprofilerfiller.push("poi");
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.POI_MANAGER_TICK); try { // Folia - profiler
         this.poiManager.tick(shouldKeepTicking);
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.POI_MANAGER_TICK); } // Folia - profiler
         gameprofilerfiller.popPush("chunk_unload");
         if (!this.level.noSave()) {
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PROCESS_UNLOADS); try { // Folia - profiler
             this.processUnloads(shouldKeepTicking);
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PROCESS_UNLOADS); } // Folia - profiler
         }
 
         gameprofilerfiller.pop();
@@ -900,13 +905,18 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     // Paper start - optimise entity tracker
     private void newTrackerTick() {
+        // Folia start - profiler
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
+        final int totalEntities;
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_TRACKER_TICK); try { // Folia - profiler
+        // Folia end - profiler
         final io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.level.getCurrentWorldData(); // Folia - region threading
         final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getNearbyPlayers();
         final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup entityLookup = (ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup)((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getEntityLookup();;
 
         final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = worldData.trackerEntities; // Folia - region threading
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
-        for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
+        for (int i = 0, len = totalEntities = trackerEntities.size(); i < len; ++i) { // Folia - region threading
             final Entity entity = trackerEntitiesRaw[i];
             final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
             if (tracker == null) {
@@ -928,6 +938,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$clearPlayers();
         }
+        profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.TRACKED_ENTITY_COUNTS, (long)totalEntities); // Folia - profiler
+        profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.TRACKED_UNLOADED_ENTITY_COUNTS, (long)unloadedEntitiesRaw.length); // Folia - profiler
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_TRACKER_TICK); } // Folia - profiler
     }
     // Paper end - optimise entity tracker
 
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index e13ccac27fa4f4c23185f12c776e80970ab844e6..135fa024d81b962761f0edc6896a2a507b6981f9 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -392,19 +392,26 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     @Override
     public void tick(BooleanSupplier shouldKeepTicking, boolean tickChunks) {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         this.level.getProfiler().push("purge");
         this.level.timings.doChunkMap.startTiming(); // Spigot
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_HOLDER_MANAGER_TICK); try { // Folia - profiler
         if (this.level.tickRateManager().runsNormally() || !tickChunks || this.level.spigotConfig.unloadFrozenChunks) { // Spigot
             this.distanceManager.purgeStaleTickets();
         }
 
         this.runDistanceManagerUpdates();
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_HOLDER_MANAGER_TICK); } // Folia - profiler
         this.level.timings.doChunkMap.stopTiming(); // Spigot
         this.level.getProfiler().popPush("chunks");
         if (tickChunks) {
             this.level.timings.chunks.startTiming(); // Paper - timings
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_CHUNK_LOADER_TICK); try { // Folia - profiler
             ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_CHUNK_LOADER_TICK); } // Folia - profiler
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK); try { // Folia - profiler
             this.tickChunks();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK); } // Folia - profiler
             this.level.timings.chunks.stopTiming(); // Paper - timings
             this.chunkMap.tick();
         }
@@ -419,6 +426,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     private void tickChunks() {
         io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.level.getCurrentWorldData(); // Folia - region threading
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         long chunksTicked = 0; // Paper - rewrite chunk system
         //long i = this.level.getGameTime(); // Folia - region threading
         long j = 1L; // Folia - region threading
@@ -431,6 +439,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             gameprofilerfiller.push("filteringLoadedChunks");
             // Paper start - chunk tick iteration optimisations
             List<ServerChunkCache.ChunkAndHolder> list;
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK_COLLECT_CHUNKS); try { // Folia - profiler
             {
                 final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.server.level.ServerChunkCache.ChunkAndHolder> tickingChunks =
                     ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getTickingChunks();
@@ -447,6 +456,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                     regionizedWorldData.iterationCopy, size // Folia - region threading
                 );
             }
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK_COLLECT_CHUNKS); } // Folia - profiler
             // Paper end - chunk tick iteration optimisations
             Iterator iterator = null; // Paper - chunk tick iteration optimisations
             if (this.level.getServer().tickRateManager().runsNormally()) this.level.timings.chunkTicks.startTiming(); // Paper
@@ -460,6 +470,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 // Paper start - Optional per player mob spawns
                 int naturalSpawnChunkCount = k;
                 NaturalSpawner.SpawnState spawnercreature_d; // moved down
+                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MOB_SPAWN_ENTITY_COUNT); try { // Folia - profiler
                 if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
                     // re-set mob counts
                     for (ServerPlayer player : this.level.getLocalPlayers()) { // Folia - region threading
@@ -479,6 +490,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 } else {
                     spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false); // Folia - region threading - note: function only cares about loaded entities, doesn't need all
                 }
+                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MOB_SPAWN_ENTITY_COUNT); } // Folia - profiler
                 // Paper end - Optional per player mob spawns
                 this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings
 
@@ -500,6 +512,9 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 boolean flag1 = this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && this.level.getLevelData().getGameTime() % this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L; // CraftBukkit
                 Iterator iterator1 = list.iterator();
 
+                long spawnChunkCount = 0L; // Folia - profiler
+                long randomChunkCount = 0L; // Folia - profiler
+                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_AND_RANDOM_TICK); try { // Folia - profiler
                 while (iterator1.hasNext()) {
                     ServerChunkCache.ChunkAndHolder chunkproviderserver_a = (ServerChunkCache.ChunkAndHolder) iterator1.next();
                     LevelChunk chunk1 = chunkproviderserver_a.chunk;
@@ -508,10 +523,12 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                     if (true && this.chunkMap.anyPlayerCloseEnoughForSpawning(chunkcoordintpair)) { // Paper - rewrite chunk system
                         chunk1.incrementInhabitedTime(j);
                         if (flag && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(chunkcoordintpair, true)) { // Spigot
+                            ++spawnChunkCount; // Folia - profiler
                             NaturalSpawner.spawnForChunk(this.level, chunk1, spawnercreature_d, this.spawnFriendlies, this.spawnEnemies, flag1);
                         }
 
                         if (true) { // Paper - rewrite chunk system
+                            ++randomChunkCount; // Folia - profiler
                             this.level.tickChunk(chunk1, l);
                             // Paper start - rewrite chunk system
                             if ((++chunksTicked & 7L) == 0L) {
@@ -521,19 +538,25 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                         }
                     }
                 }
+                profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_CHUNK_COUNT, spawnChunkCount); // Folia - profiler
+                profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.RANDOM_CHUNK_TICK_COUNT, randomChunkCount); // Folia - profiler
+                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_AND_RANDOM_TICK); } // Folia - profiler
                 this.level.timings.chunkTicks.stopTiming(); // Paper
 
                 gameprofilerfiller.popPush("customSpawners");
                 if (flag) {
+                    profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MISC_MOB_SPAWN_TICK); try { // Folia - profiler
                     try (co.aikar.timings.Timing ignored = this.level.timings.miscMobSpawning.startTiming()) { // Paper - timings
                     this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
                     } // Paper - timings
+                    } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MISC_MOB_SPAWN_TICK); } // Folia - profiler
                 }
             }
 
             gameprofilerfiller.popPush("broadcast");
             // Paper start - chunk tick iteration optimisations
             this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES); try { // Folia - profiler
             {
                 final it.unimi.dsi.fastutil.objects.ObjectArrayList<net.minecraft.server.level.ServerChunkCache.ChunkAndHolder> chunks = (it.unimi.dsi.fastutil.objects.ObjectArrayList<net.minecraft.server.level.ServerChunkCache.ChunkAndHolder>)list;
                 final ServerChunkCache.ChunkAndHolder[] raw = chunks.elements();
@@ -547,6 +570,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                     holder.holder().broadcastChanges(holder.chunk());
                 }
             }
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES); } // Folia - profiler
             this.level.timings.broadcastChunkUpdates.stopTiming(); // Paper - timing
             // Paper end - chunk tick iteration optimisations
             gameprofilerfiller.pop();
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 489b0019a859462756634a144952eb7e1fe973e3..0166d6bd686d68ffdcc42e908b0d1aa41a3bffdf 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -709,6 +709,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
 
     public void tick(BooleanSupplier shouldKeepTicking, io.papermc.paper.threadedregions.TickRegions.TickRegionData region) { // Folia - regionised ticking
         final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - regionised ticking
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         ProfilerFiller gameprofilerfiller = this.getProfiler();
 
         regionizedWorldData.setHandlingTick(true); // Folia - regionised ticking
@@ -737,9 +738,13 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         if (!this.isDebug() && flag) {
             j = regionizedWorldData.getRedstoneGameTime(); // Folia - region threading
             gameprofilerfiller.push("blockTicks");
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_TICK); try { // Folia - profiler
             regionizedWorldData.getBlockLevelTicks().tick(j, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks // Folia - region ticking
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_TICK); } // Folia - profiler
             gameprofilerfiller.popPush("fluidTicks");
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.FLUID_TICK); try { // Folia - profiler
             regionizedWorldData.getFluidLevelTicks().tick(j, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max fluid ticks // Folia - region ticking
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.FLUID_TICK); } // Folia - profiler
             gameprofilerfiller.pop();
         }
         this.timings.scheduledBlocks.stopTiming(); // Paper
@@ -747,18 +752,24 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         gameprofilerfiller.popPush("raid");
         if (flag) {
             this.timings.raids.startTiming(); // Paper - timings
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.RAIDS_TICK); try { // Folia - profiler
             this.raids.tick();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.RAIDS_TICK); } // Folia - profiler
             this.timings.raids.stopTiming(); // Paper - timings
         }
 
         gameprofilerfiller.popPush("chunkSource");
         this.timings.chunkProviderTick.startTiming(); // Paper - timings
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_PROVIDER_TICK); try { // Folia - profiler
         this.getChunkSource().tick(shouldKeepTicking, true);
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_PROVIDER_TICK); } // Folia - profiler
         this.timings.chunkProviderTick.stopTiming(); // Paper - timings
         gameprofilerfiller.popPush("blockEvents");
         if (flag) {
             this.timings.doSounds.startTiming(); // Spigot
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_EVENT_TICK); try { // Folia - profiler
             this.runBlockEvents();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_EVENT_TICK); } // Folia - profiler
             this.timings.doSounds.stopTiming(); // Spigot
         }
 
@@ -774,6 +785,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
             gameprofilerfiller.push("entities");
             this.timings.tickEntities.startTiming(); // Spigot
             if (this.dragonFight != null && flag) {
+                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.DRAGON_FIGHT_TICK); try { // Folia - profiler
                 if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this, this.dragonFight.origin)) { // Folia - region threading
                 gameprofilerfiller.push("dragonFight");
                 this.dragonFight.tick();
@@ -786,10 +798,12 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
                         fightCenter
                     );
                 } // Folia end - region threading
+                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.DRAGON_FIGHT_TICK); } // Folia - profiler
             }
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             this.timings.entityTick.startTiming(); // Spigot
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_TICK); try { // Folia - profiler
             regionizedWorldData.forEachTickingEntity((entity) -> { // Folia - regionised ticking
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
@@ -817,10 +831,13 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
                     }
                 }
             });
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_TICK); } // Folia - profiler
             this.timings.entityTick.stopTiming(); // Spigot
             this.timings.tickEntities.stopTiming(); // Spigot
             gameprofilerfiller.pop();
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY); try { // Folia - profiler
             this.tickBlockEntities();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY); } // Folia - profiler
         }
 
         gameprofilerfiller.push("entityManagement");
@@ -880,12 +897,15 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
     }
 
     public void tickCustomSpawners(boolean spawnMonsters, boolean spawnAnimals) {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         Iterator iterator = this.customSpawners.iterator();
 
         while (iterator.hasNext()) {
             CustomSpawner mobspawner = (CustomSpawner) iterator.next();
 
+            final int customSpawnerTimer = profiler.getOrCreateTimerAndStart(() -> "Misc Spawner: ".concat(io.papermc.paper.util.ObfHelper.INSTANCE.deobfClassName(mobspawner.getClass().getName()))); try { // Folia - profiler
             mobspawner.tick(this, spawnMonsters, spawnAnimals);
+            } finally { profiler.stopTimer(customSpawnerTimer); } // Folia - profiler
         }
 
     }
@@ -1352,6 +1372,11 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         // Paper start- timings
         final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(entity);
         timer = isActive ? entity.getType().tickTimer.startTiming() : entity.getType().inactiveTickTimer.startTiming(); // Paper
+        // Folia start - timer
+        final int timerId = isActive ? entity.getType().tickTimerId : entity.getType().inactiveTickTimerId;
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
+        profiler.startTimer(timerId);
+        // Folia end - timer
         try {
         // Paper end - timings
         entity.setOldPosAndRot();
@@ -1377,7 +1402,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         // Folia end - region threading
         } else { entity.inactiveTick(); } // Paper - EAR 2
         this.getProfiler().pop();
-        } finally { timer.stopTiming(); } // Paper - timings
+        } finally { timer.stopTiming(); profiler.stopTimer(timerId); } // Paper - timings // Folia - timer
         Iterator iterator = entity.getPassengers().iterator();
 
         while (iterator.hasNext()) {
@@ -1401,6 +1426,11 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
                 // Paper - EAR 2
                 final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(passenger);
                 co.aikar.timings.Timing timer = isActive ? passenger.getType().passengerTickTimer.startTiming() : passenger.getType().passengerInactiveTickTimer.startTiming(); // Paper
+                // Folia start - timer
+                final int timerId = isActive ? passenger.getType().tickTimerId : passenger.getType().inactiveTickTimerId;
+                final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
+                profiler.startTimer(timerId);
+                // Folia end - timer
                 try {
                 // Paper end
                 passenger.setOldPosAndRot();
@@ -1440,7 +1470,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
                     this.tickPassenger(passenger, entity2);
                 }
 
-            } finally { timer.stopTiming(); }// Paper - EAR2 timings
+            } finally { timer.stopTiming(); profiler.stopTimer(timerId); }// Paper - EAR2 timings // Folia - timer
             }
         } else {
             passenger.stopRiding();
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 7203bd2660514c444a09b3be42464180a8f1154b..683b5c164bf40a9d900cb96134350f2fdd06b620 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -1289,6 +1289,7 @@ public abstract class PlayerList {
 
     public void saveAll(int interval) {
         io.papermc.paper.util.MCUtil.ensureMain("Save Players" , () -> { // Paper - Ensure main
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         MinecraftTimings.savePlayers.startTiming(); // Paper
         int numSaved = 0;
         long now = System.nanoTime(); // Folia - region threading
@@ -1300,7 +1301,9 @@ public abstract class PlayerList {
             }
             // Folia end - region threading
             if (interval == -1 || now - entityplayer.lastSave >= timeInterval) { // Folia - region threading
+                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_SAVE); try { // Folia - profiler
                 this.save(entityplayer);
+                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_SAVE); } // Folia - profiler
                 // Folia start - region threading
                 if (interval != -1 && max != -1 && ++numSaved >= max) {
                     break;
diff --git a/src/main/java/net/minecraft/world/entity/EntityType.java b/src/main/java/net/minecraft/world/entity/EntityType.java
index cb61462d4691a055a4b25f7b953609d8a154fdfe..c74a01a8551457507441d266b6923b4248560abf 100644
--- a/src/main/java/net/minecraft/world/entity/EntityType.java
+++ b/src/main/java/net/minecraft/world/entity/EntityType.java
@@ -338,6 +338,13 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
         return BuiltInRegistries.ENTITY_TYPE.getOptional(ResourceLocation.tryParse(id));
     }
 
+    // Folia start - profiler
+    public final int tickTimerId;
+    public final int inactiveTickTimerId;
+    public final int passengerTickTimerId;
+    public final int passengerInactiveTickTimerId;
+    // Folia end - profiler
+
     public EntityType(EntityType.EntityFactory<T> factory, MobCategory spawnGroup, boolean saveable, boolean summonable, boolean fireImmune, boolean spawnableFarFromPlayer, ImmutableSet<Block> canSpawnInside, EntityDimensions dimensions, float spawnBoxScale, int maxTrackDistance, int trackTickInterval, FeatureFlagSet requiredFeatures) {
        // Paper start
         this(factory, spawnGroup, saveable, summonable, fireImmune, spawnableFarFromPlayer, canSpawnInside, dimensions, spawnBoxScale, maxTrackDistance, trackTickInterval, requiredFeatures, "custom");
@@ -348,6 +355,12 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
         this.passengerTickTimer = co.aikar.timings.MinecraftTimings.getEntityTimings(id, "passengerTick");
         this.passengerInactiveTickTimer = co.aikar.timings.MinecraftTimings.getEntityTimings(id, "passengerInactiveTick");
         // Paper end
+        // Folia start - profiler
+        this.tickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Entity Tick: " + id);
+        this.inactiveTickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Inactive Entity Tick: " + id);
+        this.passengerTickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Passenger Entity Tick: " + id);
+        this.passengerInactiveTickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Passenger Inactive Entity Tick: " + id);
+        // Folia end - profiler
         this.builtInRegistryHolder = BuiltInRegistries.ENTITY_TYPE.createIntrusiveHolder(this);
         this.factory = factory;
         this.category = spawnGroup;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index d963e8a6a498232a9ae760b2befaa17578a192f8..4bb14874912557008fab7361754f2d2eb98fc5aa 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -203,6 +203,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup moonrise$getEntityLookup() {
         return this.entityLookup;
     }
+    // Folia start - profiler
+    public final int tickTimerId;
+    // Folia end - profiler
 
     @Override
     public void moonrise$setEntityLookup(final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup entityLookup) {
@@ -787,6 +790,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         this.maxSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxSection(this);
         // Paper end - optimise collisions
         this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
+        // Folia start - profiler
+        this.tickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer(" Tick World: " + resourcekey.location().toString());
+        // Folia end - profiler
     }
 
     // Paper start - Cancel hit for vanished players
@@ -1406,17 +1412,21 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     protected void tickBlockEntities() {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         ProfilerFiller gameprofilerfiller = this.getProfiler();
 
         gameprofilerfiller.push("blockEntities");
         this.timings.tileEntityPending.startTiming(); // Spigot
         final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - regionised ticking
         regionizedWorldData.seTtickingBlockEntities(true); // Folia - regionised ticking
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY_PENDING); try { // Folia - profiler
         regionizedWorldData.pushPendingTickingBlockEntities(); // Folia - regionised ticking
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY_PENDING); } // Folia - profiler
         List<TickingBlockEntity> blockEntityTickers = regionizedWorldData.getBlockEntityTickers(); // Folia - regionised ticking
         this.timings.tileEntityPending.stopTiming(); // Spigot
 
         this.timings.tileEntityTick.startTiming(); // Spigot
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY_TICK); try { // Folia - profiler
         // Spigot start
         // Iterator<TickingBlockEntity> iterator = this.blockEntityTickers.iterator();
         boolean flag = this.tickRateManager().runsNormally();
@@ -1445,6 +1455,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             }
         }
         blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075 // Folia - regionised ticking
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY_TICK); } // Folia - profiler
 
         this.timings.tileEntityTick.stopTiming(); // Spigot
         regionizedWorldData.seTtickingBlockEntities(false); // Folia - regionised ticking
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntityType.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntityType.java
index 96b99aab3720e5bdf293fd4a95944c7218ce43c0..e7691f856f85469c06f2b5a2a3db3120ec6f193d 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntityType.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntityType.java
@@ -283,10 +283,17 @@ public class BlockEntityType<T extends BlockEntity> {
         }
 
         Type<?> type = Util.fetchChoiceType(References.BLOCK_ENTITY, id);
-        return Registry.register(BuiltInRegistries.BLOCK_ENTITY_TYPE, id, builder.build(type));
+        return Registry.register(BuiltInRegistries.BLOCK_ENTITY_TYPE, id, builder.build(type, id)); // Folia - profiler
     }
 
     public BlockEntityType(BlockEntityType.BlockEntitySupplier<? extends T> factory, Set<Block> blocks, Type<?> type) {
+        // Folia start - profiler
+        this(factory, blocks, type, "custom");
+    }
+    public final int tileEntityTimingId;
+    public BlockEntityType(BlockEntityType.BlockEntitySupplier<? extends T> factory, Set<Block> blocks, Type<?> type, String id) {
+        this.tileEntityTimingId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Tile Entity Tick: " + id);
+        // Folia end - profiler
         this.factory = factory;
         this.validBlocks = blocks;
         this.dataType = type;
@@ -331,7 +338,12 @@ public class BlockEntityType<T extends BlockEntity> {
         }
 
         public BlockEntityType<T> build(Type<?> type) {
-            return new BlockEntityType<>(this.factory, this.validBlocks, type);
+            // Folia start - profiler
+            return this.build(type, "custom");
+        }
+        public BlockEntityType<T> build(Type<?> type, String id) {
+            return new BlockEntityType<>(this.factory, this.validBlocks, type, id);
+            // Folia end - profiler
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 2c39642298bf235565b92287efaf55373183c5a1..e0359a8857387428d44c19af8dd0e2e743a0b2b5 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -1039,11 +1039,14 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
                 BlockPos blockposition = this.blockEntity.getBlockPos();
 
                 if (LevelChunk.this.isTicking(blockposition)) {
+                    final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+                    final int timerId = this.blockEntity.getType().tileEntityTimingId; // Folia - profiler
                     try {
                         ProfilerFiller gameprofilerfiller = LevelChunk.this.level.getProfiler();
 
                         gameprofilerfiller.push(this::getType);
                         this.blockEntity.tickTimer.startTiming(); // Spigot
+                        profiler.startTimer(timerId); try { // Folia - profiler
                         BlockState iblockdata = LevelChunk.this.getBlockState(blockposition);
 
                         if (this.blockEntity.getType().isValid(iblockdata)) {
@@ -1058,6 +1061,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
                             }
                             // Paper end - Remove the Block Entity if it's invalid
                         }
+                        } finally { profiler.stopTimer(timerId); } // Folia - profiler
 
                         gameprofilerfiller.pop();
                     } catch (Throwable throwable) {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index ea161048b68de3c8cdcba5f4cb66eb1531364b2e..073d8176a7ee347f81edb18292de26629ca95e06 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -250,6 +250,12 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void runCollectedTicks(BiConsumer<BlockPos, T> ticker) {
+        // Folia start - profiler
+        io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler().addCounter(
+            ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_OR_FLUID_TICK_COUNT,
+            (long)this.toRunThisTick.size()
+        );
+        // Folia end - profiler
         while (!this.toRunThisTick.isEmpty()) {
             ScheduledTick<T> scheduledTick = this.toRunThisTick.poll();
             if (!this.toRunThisTickSet.isEmpty()) {
